{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"prefect-ray Welcome! Prefect integrations with the Ray execution framework, a flexible distributed computing framework for Python. Provides a RayTaskRunner that enables flows to run tasks requiring parallel execution using Ray. Getting Started Python setup Requires an installation of Python 3.7+. We recommend using a Python virtual environment manager such as pipenv, conda, or virtualenv. These tasks are designed to work with Prefect 2.0. For more information about how to use Prefect, please refer to the Prefect documentation . Installation Install prefect-ray with pip : pip install prefect-ray Users running Apple Silicon (such as M1 macs) will need to additionally run: pip uninstall grpcio conda install grpcio Click here for more details. Running tasks on Ray The RayTaskRunner is a Prefect task runner that submits tasks to Ray for parallel execution. By default, a temporary Ray instance is created for the duration of the flow run. For example, this flow counts to 3 in parallel. import time from prefect import flow , task from prefect_ray import RayTaskRunner @task def shout ( number ): time . sleep ( 0.5 ) print ( f \"# { number } \" ) @flow ( task_runner = RayTaskRunner ) def count_to ( highest_number ): for number in range ( highest_number ): shout . submit ( number ) if __name__ == \"__main__\" : count_to ( 10 ) # outputs #3 #7 #2 #6 #4 #0 #1 #5 #8 #9 If you already have a Ray instance running, you can provide the connection URL via an address argument. To configure your flow to use the RayTaskRunner : Make sure the prefect-ray collection is installed as described earlier: pip install prefect-ray . In your flow code, import RayTaskRunner from prefect_ray.task_runners . Assign it as the task runner when the flow is defined using the task_runner=RayTaskRunner argument. For example, this flow uses the RayTaskRunner with a local, temporary Ray instance created by Prefect at flow run time. from prefect import flow from prefect_ray.task_runners import RayTaskRunner @flow ( task_runner = RayTaskRunner ()) def my_flow (): ... This flow uses the RayTaskRunner configured to access an existing Ray instance at ray://192.0.2.255:8786 . from prefect import flow from prefect_ray.task_runners import RayTaskRunner @flow ( task_runner = RayTaskRunner ( address = \"ray://192.0.2.255:8786\" )) def my_flow (): ... RayTaskRunner accepts the following optional parameters: Parameter Description address Address of a currently running Ray instance, starting with the ray:// URI. init_kwargs Additional kwargs to use when calling ray.init . Note that Ray Client uses the ray:// URI to indicate the address of a Ray instance. If you don't provide the address of a Ray instance, Prefect creates a temporary instance automatically. Ray environment limitations While we're excited about adding support for parallel task execution via Ray to Prefect, there are some inherent limitations with Ray you should be aware of: Ray currently does not support Python 3.10. Ray support for non-x86/64 architectures such as ARM/M1 processors with installation from pip alone and will be skipped during installation of Prefect. It is possible to manually install the blocking component with conda . See the Ray documentation for instructions. See the Ray installation documentation for further compatibility information. Running tasks on a Ray remote cluster When using the RayTaskRunner with a remote Ray cluster, you may run into issues that are not seen when using a local Ray instance. To resolve these issues, we recommend taking the following steps when working with a remote Ray cluster: By default, Prefect will not persist any data to the filesystem of the remote ray worker. However, if you want to take advantage of Prefect's caching ability, you will need to configure a remote result storage to persist results across task runs. We recommend using the Prefect UI to configure a storage block to use for remote results storage. Here's an example of a flow that uses caching and remote result storage: from typing import List from prefect import flow , get_run_logger , task from prefect.filesystems import S3 from prefect.tasks import task_input_hash from prefect_ray.task_runners import RayTaskRunner # The result of this task will be cached in the configured result storage @task ( cache_key_fn = task_input_hash ) def say_hello ( name : str ) -> None : logger = get_run_logger () # This log statement will print only on the first run. Subsequent runs will be cached. logger . info ( f \"hello { name } !\" ) return name @flow ( task_runner = RayTaskRunner ( address = \"ray://<instance_public_ip_address>:10001\" , ), # Using an S3 block that has already been created via the Prefect UI result_storage = \"s3/my-result-storage\" , ) def greetings ( names : List [ str ]) -> None : for name in names : say_hello . submit ( name ) if __name__ == \"__main__\" : greetings ([ \"arthur\" , \"trillian\" , \"ford\" , \"marvin\" ]) If you get an error stating that the module 'prefect' cannot be found, ensure prefect is installed on the remote cluster, with: pip install prefect If you get an error with a message similar to \"File system created with scheme 's3' could not be created\", ensure the required Python modules are installed on both local and remote machines . The required prerequisite modules can be found in the Prefect documentation . For example, if using S3 for the remote storage: pip install s3fs If you are seeing timeout or other connection errors, double check the address provided to the RayTaskRunner . The address should look similar to: address='ray://<head_node_ip_address>:10001' : RayTaskRunner ( address = \"ray://1.23.199.255:10001\" ) Resources If you encounter and bugs while using prefect-ray , feel free to open an issue in the prefect-ray repository. If you have any questions or issues while using prefect-ray , you can find help in either the Prefect Discourse forum or the Prefect Slack community . Feel free to \u2b50\ufe0f or watch prefect-ray for updates too! Development If you'd like to install a version of prefect-ray for development, clone the repository and perform an editable install with pip : git clone https://github.com/PrefectHQ/prefect-ray.git cd prefect-ray/ pip install -e \".[dev]\" # Install linting pre-commit hooks pre-commit install","title":"Home"},{"location":"#prefect-ray","text":"","title":"prefect-ray"},{"location":"#welcome","text":"Prefect integrations with the Ray execution framework, a flexible distributed computing framework for Python. Provides a RayTaskRunner that enables flows to run tasks requiring parallel execution using Ray.","title":"Welcome!"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"#python-setup","text":"Requires an installation of Python 3.7+. We recommend using a Python virtual environment manager such as pipenv, conda, or virtualenv. These tasks are designed to work with Prefect 2.0. For more information about how to use Prefect, please refer to the Prefect documentation .","title":"Python setup"},{"location":"#installation","text":"Install prefect-ray with pip : pip install prefect-ray Users running Apple Silicon (such as M1 macs) will need to additionally run: pip uninstall grpcio conda install grpcio Click here for more details.","title":"Installation"},{"location":"#running-tasks-on-ray","text":"The RayTaskRunner is a Prefect task runner that submits tasks to Ray for parallel execution. By default, a temporary Ray instance is created for the duration of the flow run. For example, this flow counts to 3 in parallel. import time from prefect import flow , task from prefect_ray import RayTaskRunner @task def shout ( number ): time . sleep ( 0.5 ) print ( f \"# { number } \" ) @flow ( task_runner = RayTaskRunner ) def count_to ( highest_number ): for number in range ( highest_number ): shout . submit ( number ) if __name__ == \"__main__\" : count_to ( 10 ) # outputs #3 #7 #2 #6 #4 #0 #1 #5 #8 #9 If you already have a Ray instance running, you can provide the connection URL via an address argument. To configure your flow to use the RayTaskRunner : Make sure the prefect-ray collection is installed as described earlier: pip install prefect-ray . In your flow code, import RayTaskRunner from prefect_ray.task_runners . Assign it as the task runner when the flow is defined using the task_runner=RayTaskRunner argument. For example, this flow uses the RayTaskRunner with a local, temporary Ray instance created by Prefect at flow run time. from prefect import flow from prefect_ray.task_runners import RayTaskRunner @flow ( task_runner = RayTaskRunner ()) def my_flow (): ... This flow uses the RayTaskRunner configured to access an existing Ray instance at ray://192.0.2.255:8786 . from prefect import flow from prefect_ray.task_runners import RayTaskRunner @flow ( task_runner = RayTaskRunner ( address = \"ray://192.0.2.255:8786\" )) def my_flow (): ... RayTaskRunner accepts the following optional parameters: Parameter Description address Address of a currently running Ray instance, starting with the ray:// URI. init_kwargs Additional kwargs to use when calling ray.init . Note that Ray Client uses the ray:// URI to indicate the address of a Ray instance. If you don't provide the address of a Ray instance, Prefect creates a temporary instance automatically. Ray environment limitations While we're excited about adding support for parallel task execution via Ray to Prefect, there are some inherent limitations with Ray you should be aware of: Ray currently does not support Python 3.10. Ray support for non-x86/64 architectures such as ARM/M1 processors with installation from pip alone and will be skipped during installation of Prefect. It is possible to manually install the blocking component with conda . See the Ray documentation for instructions. See the Ray installation documentation for further compatibility information.","title":"Running tasks on Ray"},{"location":"#running-tasks-on-a-ray-remote-cluster","text":"When using the RayTaskRunner with a remote Ray cluster, you may run into issues that are not seen when using a local Ray instance. To resolve these issues, we recommend taking the following steps when working with a remote Ray cluster: By default, Prefect will not persist any data to the filesystem of the remote ray worker. However, if you want to take advantage of Prefect's caching ability, you will need to configure a remote result storage to persist results across task runs. We recommend using the Prefect UI to configure a storage block to use for remote results storage. Here's an example of a flow that uses caching and remote result storage: from typing import List from prefect import flow , get_run_logger , task from prefect.filesystems import S3 from prefect.tasks import task_input_hash from prefect_ray.task_runners import RayTaskRunner # The result of this task will be cached in the configured result storage @task ( cache_key_fn = task_input_hash ) def say_hello ( name : str ) -> None : logger = get_run_logger () # This log statement will print only on the first run. Subsequent runs will be cached. logger . info ( f \"hello { name } !\" ) return name @flow ( task_runner = RayTaskRunner ( address = \"ray://<instance_public_ip_address>:10001\" , ), # Using an S3 block that has already been created via the Prefect UI result_storage = \"s3/my-result-storage\" , ) def greetings ( names : List [ str ]) -> None : for name in names : say_hello . submit ( name ) if __name__ == \"__main__\" : greetings ([ \"arthur\" , \"trillian\" , \"ford\" , \"marvin\" ]) If you get an error stating that the module 'prefect' cannot be found, ensure prefect is installed on the remote cluster, with: pip install prefect If you get an error with a message similar to \"File system created with scheme 's3' could not be created\", ensure the required Python modules are installed on both local and remote machines . The required prerequisite modules can be found in the Prefect documentation . For example, if using S3 for the remote storage: pip install s3fs If you are seeing timeout or other connection errors, double check the address provided to the RayTaskRunner . The address should look similar to: address='ray://<head_node_ip_address>:10001' : RayTaskRunner ( address = \"ray://1.23.199.255:10001\" )","title":"Running tasks on a Ray remote cluster"},{"location":"#resources","text":"If you encounter and bugs while using prefect-ray , feel free to open an issue in the prefect-ray repository. If you have any questions or issues while using prefect-ray , you can find help in either the Prefect Discourse forum or the Prefect Slack community . Feel free to \u2b50\ufe0f or watch prefect-ray for updates too!","title":"Resources"},{"location":"#development","text":"If you'd like to install a version of prefect-ray for development, clone the repository and perform an editable install with pip : git clone https://github.com/PrefectHQ/prefect-ray.git cd prefect-ray/ pip install -e \".[dev]\" # Install linting pre-commit hooks pre-commit install","title":"Development"},{"location":"task_runners/","text":"prefect_ray.task_runners Interface and implementations of the Ray Task Runner. Task Runners in Prefect are responsible for managing the execution of Prefect task runs. Generally speaking, users are not expected to interact with task runners outside of configuring and initializing them for a flow. Example import time from prefect import flow , task @task def shout ( number ): time . sleep ( 0.5 ) print ( f \"# { number } \" ) @flow def count_to ( highest_number ): for number in range ( highest_number ): shout . submit ( number ) if __name__ == \"__main__\" : count_to ( 10 ) # outputs #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 Switching to a RayTaskRunner : import time from prefect import flow , task from prefect_ray import RayTaskRunner @task def shout ( number ): time . sleep ( 0.5 ) print ( f \"# { number } \" ) @flow ( task_runner = RayTaskRunner ) def count_to ( highest_number ): for number in range ( highest_number ): shout . submit ( number ) if __name__ == \"__main__\" : count_to ( 10 ) # outputs #3 #7 #2 #6 #4 #0 #1 #5 #8 #9 Classes RayTaskRunner Bases: BaseTaskRunner A parallel task_runner that submits tasks to ray . By default, a temporary Ray cluster is created for the duration of the flow run. Alternatively, if you already have a ray instance running, you can provide the connection URL via the address kwarg. Parameters: Name Type Description Default address string Address of a currently running ray instance; if one is not provided, a temporary instance will be created. None init_kwargs dict Additional kwargs to use when calling ray.init . None Examples: Using a temporary local ray cluster: from prefect import flow from prefect_ray.task_runners import RayTaskRunner @flow ( task_runner = RayTaskRunner ()) def my_flow (): ... Connecting to an existing ray instance: RayTaskRunner ( address = \"ray://192.0.2.255:8786\" ) Source code in prefect_ray/task_runners.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 class RayTaskRunner ( BaseTaskRunner ): \"\"\" A parallel task_runner that submits tasks to `ray`. By default, a temporary Ray cluster is created for the duration of the flow run. Alternatively, if you already have a `ray` instance running, you can provide the connection URL via the `address` kwarg. Args: address (string, optional): Address of a currently running `ray` instance; if one is not provided, a temporary instance will be created. init_kwargs (dict, optional): Additional kwargs to use when calling `ray.init`. Examples: Using a temporary local ray cluster: ```python from prefect import flow from prefect_ray.task_runners import RayTaskRunner @flow(task_runner=RayTaskRunner()) def my_flow(): ... ``` Connecting to an existing ray instance: ```python RayTaskRunner(address=\"ray://192.0.2.255:8786\") ``` \"\"\" def __init__ ( self , address : str = None , init_kwargs : dict = None , ): # Store settings self . address = address self . init_kwargs = init_kwargs . copy () if init_kwargs else {} self . init_kwargs . setdefault ( \"namespace\" , \"prefect\" ) self . init_kwargs # Runtime attributes self . _ray_refs : Dict [ str , \"ray.ObjectRef\" ] = {} super () . __init__ () @property def concurrency_type ( self ) -> TaskConcurrencyType : return TaskConcurrencyType . PARALLEL async def submit ( self , key : UUID , call : Callable [ ... , Awaitable [ State [ R ]]], ) -> None : if not self . _started : raise RuntimeError ( \"The task runner must be started before submitting work.\" ) call_kwargs = self . _optimize_futures ( call . keywords ) # Ray does not support the submission of async functions and we must create a # sync entrypoint self . _ray_refs [ key ] = ray . remote ( sync_compatible ( call . func )) . remote ( ** call_kwargs ) def _optimize_futures ( self , expr ): \"\"\" Exchange PrefectFutures for ray-compatible futures \"\"\" def visit_fn ( expr ): \"\"\" Resolves ray futures when used as dependencies \"\"\" if isinstance ( expr , PrefectFuture ): ray_future = self . _ray_refs . get ( expr . key ) if ray_future is not None : return ray . get ( ray_future ) # Fallback to return the expression unaltered return expr return visit_collection ( expr , visit_fn = visit_fn , return_data = True ) async def wait ( self , key : UUID , timeout : float = None ) -> Optional [ State ]: ref = self . _get_ray_ref ( key ) result = None with anyio . move_on_after ( timeout ): # We await the reference directly instead of using `ray.get` so we can # avoid blocking the event loop try : result = await ref except BaseException as exc : result = exception_to_crashed_state ( exc ) return result async def _start ( self , exit_stack : AsyncExitStack ): \"\"\" Start the task runner and prep for context exit. - Creates a cluster if an external address is not set. - Creates a client to connect to the cluster. - Pushes a call to wait for all running futures to complete on exit. \"\"\" if self . address and self . address != \"auto\" : self . logger . info ( f \"Connecting to an existing Ray instance at { self . address } \" ) init_args = ( self . address ,) elif ray . is_initialized (): self . logger . info ( \"Local Ray instance is already initialized. \" \"Using existing local instance.\" ) return else : self . logger . info ( \"Creating a local Ray instance\" ) init_args = () context = ray . init ( * init_args , ** self . init_kwargs ) dashboard_url = getattr ( context , \"dashboard_url\" , None ) exit_stack . push ( context ) # Display some information about the cluster nodes = ray . nodes () living_nodes = [ node for node in nodes if node . get ( \"alive\" )] self . logger . info ( f \"Using Ray cluster with { len ( living_nodes ) } nodes.\" ) if dashboard_url : self . logger . info ( f \"The Ray UI is available at { dashboard_url } \" , ) async def _shutdown_ray ( self ): \"\"\" Shuts down the cluster. \"\"\" self . logger . debug ( \"Shutting down Ray cluster...\" ) ray . shutdown () def _get_ray_ref ( self , key : UUID ) -> \"ray.ObjectRef\" : \"\"\" Retrieve the ray object reference corresponding to a prefect future. \"\"\" return self . _ray_refs [ key ]","title":"Task Runners"},{"location":"task_runners/#prefect_ray.task_runners","text":"Interface and implementations of the Ray Task Runner. Task Runners in Prefect are responsible for managing the execution of Prefect task runs. Generally speaking, users are not expected to interact with task runners outside of configuring and initializing them for a flow. Example import time from prefect import flow , task @task def shout ( number ): time . sleep ( 0.5 ) print ( f \"# { number } \" ) @flow def count_to ( highest_number ): for number in range ( highest_number ): shout . submit ( number ) if __name__ == \"__main__\" : count_to ( 10 ) # outputs #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 Switching to a RayTaskRunner : import time from prefect import flow , task from prefect_ray import RayTaskRunner @task def shout ( number ): time . sleep ( 0.5 ) print ( f \"# { number } \" ) @flow ( task_runner = RayTaskRunner ) def count_to ( highest_number ): for number in range ( highest_number ): shout . submit ( number ) if __name__ == \"__main__\" : count_to ( 10 ) # outputs #3 #7 #2 #6 #4 #0 #1 #5 #8 #9","title":"task_runners"},{"location":"task_runners/#prefect_ray.task_runners-classes","text":"","title":"Classes"},{"location":"task_runners/#prefect_ray.task_runners.RayTaskRunner","text":"Bases: BaseTaskRunner A parallel task_runner that submits tasks to ray . By default, a temporary Ray cluster is created for the duration of the flow run. Alternatively, if you already have a ray instance running, you can provide the connection URL via the address kwarg. Parameters: Name Type Description Default address string Address of a currently running ray instance; if one is not provided, a temporary instance will be created. None init_kwargs dict Additional kwargs to use when calling ray.init . None Examples: Using a temporary local ray cluster: from prefect import flow from prefect_ray.task_runners import RayTaskRunner @flow ( task_runner = RayTaskRunner ()) def my_flow (): ... Connecting to an existing ray instance: RayTaskRunner ( address = \"ray://192.0.2.255:8786\" ) Source code in prefect_ray/task_runners.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 class RayTaskRunner ( BaseTaskRunner ): \"\"\" A parallel task_runner that submits tasks to `ray`. By default, a temporary Ray cluster is created for the duration of the flow run. Alternatively, if you already have a `ray` instance running, you can provide the connection URL via the `address` kwarg. Args: address (string, optional): Address of a currently running `ray` instance; if one is not provided, a temporary instance will be created. init_kwargs (dict, optional): Additional kwargs to use when calling `ray.init`. Examples: Using a temporary local ray cluster: ```python from prefect import flow from prefect_ray.task_runners import RayTaskRunner @flow(task_runner=RayTaskRunner()) def my_flow(): ... ``` Connecting to an existing ray instance: ```python RayTaskRunner(address=\"ray://192.0.2.255:8786\") ``` \"\"\" def __init__ ( self , address : str = None , init_kwargs : dict = None , ): # Store settings self . address = address self . init_kwargs = init_kwargs . copy () if init_kwargs else {} self . init_kwargs . setdefault ( \"namespace\" , \"prefect\" ) self . init_kwargs # Runtime attributes self . _ray_refs : Dict [ str , \"ray.ObjectRef\" ] = {} super () . __init__ () @property def concurrency_type ( self ) -> TaskConcurrencyType : return TaskConcurrencyType . PARALLEL async def submit ( self , key : UUID , call : Callable [ ... , Awaitable [ State [ R ]]], ) -> None : if not self . _started : raise RuntimeError ( \"The task runner must be started before submitting work.\" ) call_kwargs = self . _optimize_futures ( call . keywords ) # Ray does not support the submission of async functions and we must create a # sync entrypoint self . _ray_refs [ key ] = ray . remote ( sync_compatible ( call . func )) . remote ( ** call_kwargs ) def _optimize_futures ( self , expr ): \"\"\" Exchange PrefectFutures for ray-compatible futures \"\"\" def visit_fn ( expr ): \"\"\" Resolves ray futures when used as dependencies \"\"\" if isinstance ( expr , PrefectFuture ): ray_future = self . _ray_refs . get ( expr . key ) if ray_future is not None : return ray . get ( ray_future ) # Fallback to return the expression unaltered return expr return visit_collection ( expr , visit_fn = visit_fn , return_data = True ) async def wait ( self , key : UUID , timeout : float = None ) -> Optional [ State ]: ref = self . _get_ray_ref ( key ) result = None with anyio . move_on_after ( timeout ): # We await the reference directly instead of using `ray.get` so we can # avoid blocking the event loop try : result = await ref except BaseException as exc : result = exception_to_crashed_state ( exc ) return result async def _start ( self , exit_stack : AsyncExitStack ): \"\"\" Start the task runner and prep for context exit. - Creates a cluster if an external address is not set. - Creates a client to connect to the cluster. - Pushes a call to wait for all running futures to complete on exit. \"\"\" if self . address and self . address != \"auto\" : self . logger . info ( f \"Connecting to an existing Ray instance at { self . address } \" ) init_args = ( self . address ,) elif ray . is_initialized (): self . logger . info ( \"Local Ray instance is already initialized. \" \"Using existing local instance.\" ) return else : self . logger . info ( \"Creating a local Ray instance\" ) init_args = () context = ray . init ( * init_args , ** self . init_kwargs ) dashboard_url = getattr ( context , \"dashboard_url\" , None ) exit_stack . push ( context ) # Display some information about the cluster nodes = ray . nodes () living_nodes = [ node for node in nodes if node . get ( \"alive\" )] self . logger . info ( f \"Using Ray cluster with { len ( living_nodes ) } nodes.\" ) if dashboard_url : self . logger . info ( f \"The Ray UI is available at { dashboard_url } \" , ) async def _shutdown_ray ( self ): \"\"\" Shuts down the cluster. \"\"\" self . logger . debug ( \"Shutting down Ray cluster...\" ) ray . shutdown () def _get_ray_ref ( self , key : UUID ) -> \"ray.ObjectRef\" : \"\"\" Retrieve the ray object reference corresponding to a prefect future. \"\"\" return self . _ray_refs [ key ]","title":"RayTaskRunner"}]}